<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>R3CALL</title>
    <link>http://www.r3call.com/</link>
    <description>R3CALL</description>
    <pubDate>Fri, 18 Mar 2016 21:09:33 +0800</pubDate>
    <item>
      <title>Git 2.0 更改 push default 为 simple</title>
      <link>http://www.r3call.com/2016/3/16/git-更改push.default.html</link>
      <description>&lt;p&gt;如果你最近更新了 Git，你可能会在执行 git push 时看到如下消息：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;warning: push.default is unset; its implicit value is changing in&#xA;Git 2.0 from &amp;lsquo;matching&amp;rsquo; to &amp;lsquo;simple&amp;rsquo;. To squelch this message&#xA;and maintain the current behavior after the default changes, use:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git config --global push.default matching&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To squelch this message and adopt the new behavior now, use:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git config --global push.default simple&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2 id=&#34;matching&#34;&gt;Matching&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;‘matching’ 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;simple&#34;&gt;Simple&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;而 Git 2.x 默认的是 simple，意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;修改默认设置&#34;&gt;修改默认设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;从上述消息提示中的解释，我们可以修改全局配置，使之不会每次 push 的时候都进行提示。对于 matching 输入如下命令即可：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global push.default matching&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;而对于 simple ，请输入：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global push.default simple&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <pubDate>Wed, 16 Mar 2016 11:49:29 +0000</pubDate>
    </item>
    <item>
      <title>手动安装 atom 扩展包 packages</title>
      <link>http://www.r3call.com/2016/3/16/install-atom-packages.html</link>
      <description>&lt;p&gt;由于众所周知的原因, 我们下载 atom 扩展时会发现速度特别慢, 或者根本无法下载, 那我们可以尝试手动安装&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先, 从 github 上下载(或其它地方) 扩展包, 解压&#xA;进入该文件夹, 找到 &lt;code&gt;package.json&lt;/code&gt; 文件所在的目录&#xA;执行命令&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果依赖比较多, 可以尝试一个一个独立安装.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有一种安装方式是执行:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apm install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;不过我没有尝试过该方案.&lt;/p&gt;&#xA;</description>
      <pubDate>Wed, 16 Mar 2016 00:28:01 +0000</pubDate>
    </item>
    <item>
      <title>从零开始分析 Django 源码 (三)</title>
      <link>http://www.r3call.com/2016/3/15/从零开始分析Django源码3.html</link>
      <description>&lt;p&gt;工作太忙,实在是没时间写东西.&#xA;今天来分析下 get_object_or_404 的源码&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;1-一个-get-object-or-404-的例子&#34;&gt;1. 一个 get_object_or_404 的例子&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def compnay_files_list(request,company_id):&#xA;    company = get_object_or_404(Company,id = company_id)&#xA;    fileowner_type = ContentType.objects.get_for_model(company)&#xA;    &#xA;    return render_to_response(&#39;company/company_files.html&#39;, {&#xA;        &#39;company&#39;:company,&#39;contenttype_id&#39;:fileowner_type.id&#xA;    }, context_instance=RequestContext(request))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;2-我们来分析分析-get-object-or-404&#34;&gt;2. 我们来分析分析 get_object_or_404&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_object_or_404(klass, *args, **kwargs):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Uses get() to return an object, or raises a Http404 exception if the object&#xA;    does not exist.&#xA;&#xA;    klass may be a Model, Manager, or QuerySet object. All other passed&#xA;    arguments and keyword arguments are used in the get() query.&#xA;&#xA;    Note: Like with get(), an MultipleObjectsReturned will be raised if more than one&#xA;    object is found.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    queryset = _get_queryset(klass)&#xA;    try:&#xA;        return queryset.get(*args, **kwargs)&#xA;    except queryset.model.DoesNotExist:&#xA;        raise Http404(&#39;No %s matches the given query.&#39; % queryset.model._meta.object_name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4 id=&#34;2-1-我们先来分析-get-queryset-这个函数&#34;&gt;2.1 我们先来分析 _get_queryset 这个函数&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _get_queryset(klass):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    Returns a QuerySet from a Model, Manager, or QuerySet. Created to make&#xA;    get_object_or_404 and get_list_or_404 more DRY.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    if isinstance(klass, QuerySet):&#xA;        return klass&#xA;    elif isinstance(klass, Manager):&#xA;        manager = klass&#xA;    else:&#xA;        manager = klass._default_manager&#xA;    return manager.all()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果是 QuerySet ,直接返回&#xA;如果是 Manager ,返回  Manager.all() ,其实也是 QuerySet&#xA;如果都不是,一般就会是一个 Model 名, 获得 默认的 Manager,然后 Manager.all() ,最后还是返回 QuerySet&#xA;所以结论就是返回 QuerySet&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;2-2-继续分析get-object-or-404&#34;&gt;2.2 继续分析get_object_or_404&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;返回了 QuerySet 对象之后,再get 取值就OK了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;klass may be a Model, Manager, or QuerySet object.&#xA;这里已经说得很清楚, klass 可以是 Model , Manager, 或者 QuerySet 对象.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;PS: python 中,类也是对象&lt;/p&gt;&#xA;</description>
      <pubDate>Tue, 15 Mar 2016 23:50:24 +0000</pubDate>
    </item>
    <item>
      <title>从零开始分析 Django 源码 (二)</title>
      <link>http://www.r3call.com/2016/3/15/从零开始分析Django源码2.html</link>
      <description>&lt;h1 id=&#34;从-中间件-和-response-继续分析&#34;&gt;从 &lt;strong&gt;中间件&lt;/strong&gt; 和 &lt;strong&gt;response&lt;/strong&gt; 继续分析&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;上次我们分析了 Django 的 startproject 和 startapp，按照我们学习的规律，我们应该继续分析 syncdb 和 runserver 两个 command，但是，由于对wsgi 和 数据库不够了解，所以我们可以先尝试分析其它的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Django/core/handler/wsgi.py 下的 WSGIHandler 有两个关键的调用，我们先来看看代码&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class WSGIHandler(base.BaseHandler):&#xA;    initLock = Lock()&#xA;    request_class = WSGIRequest&#xA;&#xA;    def __call__(self, environ, start_response):&#xA;        # Set up middleware if needed. We couldn&#39;t do this earlier, because&#xA;        # settings weren&#39;t available.&#xA;        if self._request_middleware is None:&#xA;            with self.initLock:&#xA;                try:&#xA;                    # Check that middleware is still uninitialised.&#xA;                    if self._request_middleware is None:&#xA;                        self.load_middleware()&#xA;                        # 加载中间件&#xA;                except:&#xA;                    # Unload whatever middleware we got&#xA;                    self._request_middleware = None&#xA;                    raise&#xA;&#xA;        set_script_prefix(base.get_script_name(environ))&#xA;        signals.request_started.send(sender=self.__class__)&#xA;        try:&#xA;            request = self.request_class(environ)&#xA;        except UnicodeDecodeError:&#xA;            logger.warning(&#39;Bad Request (UnicodeDecodeError)&#39;,&#xA;                exc_info=sys.exc_info(),&#xA;                extra={&#xA;                    &#39;status_code&#39;: 400,&#xA;                }&#xA;            )&#xA;            response = http.HttpResponseBadRequest()&#xA;        else:&#xA;            response = self.get_response(request)&#xA;            # 获得 response&#xA;&#xA;        response._handler_class = self.__class__&#xA;&#xA;        status = &#39;%s %s&#39; % (response.status_code, response.reason_phrase)&#xA;        response_headers = [(str(k), str(v)) for k, v in response.items()]&#xA;        for c in response.cookies.values():&#xA;            response_headers.append((str(&#39;Set-Cookie&#39;), str(c.output(header=&#39;&#39;))))&#xA;        start_response(force_str(status), response_headers)&#xA;        return response&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这两个关键的调用是 load_middleware 和 get_response。&#xA;它们的具体实现时在 BaseHandler 中，我们跟进&#xA;Django/core/handler/base.py&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;1-加载-中间件&#34;&gt;1.加载 中间件&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def load_middleware(self):&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        Populate middleware lists from settings.MIDDLEWARE_CLASSES.&#xA;&#xA;        Must be called after the environment is fixed (see __call__ in subclasses).&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        self._view_middleware = []&#xA;        self._template_response_middleware = []&#xA;        self._response_middleware = []&#xA;        self._exception_middleware = []&#xA;&#xA;        request_middleware = []&#xA;        for middleware_path in settings.MIDDLEWARE_CLASSES:&#xA;            print 45,&#39;django.handler.base.BaseHandler&#39;&#xA;            print 46,middleware_path&#xA;            mw_class = import_by_path(middleware_path)&#xA;            try:&#xA;                mw_instance = mw_class()&#xA;                print 50,mw_instance.__class__&#xA;            except MiddlewareNotUsed:&#xA;                continue&#xA;&#xA;            if hasattr(mw_instance, &#39;process_request&#39;):&#xA;                request_middleware.append(mw_instance.process_request)&#xA;            if hasattr(mw_instance, &#39;process_view&#39;):&#xA;                self._view_middleware.append(mw_instance.process_view)&#xA;            if hasattr(mw_instance, &#39;process_template_response&#39;):&#xA;                self._template_response_middleware.insert(0, mw_instance.process_template_response)&#xA;            if hasattr(mw_instance, &#39;process_response&#39;):&#xA;                self._response_middleware.insert(0, mw_instance.process_response)&#xA;            if hasattr(mw_instance, &#39;process_exception&#39;):&#xA;                self._exception_middleware.insert(0, mw_instance.process_exception)&#xA;&#xA;        # We only assign to this when initialization is complete as it is used&#xA;        # as a flag for initialization being complete.&#xA;        self._request_middleware = request_middleware&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我加了一些打印，我们来看看输出&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;45 django.handler.base.BaseHandler&#xA;46 django.contrib.sessions.middleware.SessionMiddleware&#xA;50 &amp;lt;class &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;&amp;gt;&#xA;45 django.handler.base.BaseHandler&#xA;46 django.middleware.common.CommonMiddleware&#xA;50 &amp;lt;class &#39;django.middleware.common.CommonMiddleware&#39;&amp;gt;&#xA;45 django.handler.base.BaseHandler&#xA;46 django.middleware.csrf.CsrfViewMiddleware&#xA;50 &amp;lt;class &#39;django.middleware.csrf.CsrfViewMiddleware&#39;&amp;gt;&#xA;45 django.handler.base.BaseHandler&#xA;46 django.contrib.auth.middleware.AuthenticationMiddleware&#xA;50 &amp;lt;class &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;&amp;gt;&#xA;45 django.handler.base.BaseHandler&#xA;46 django.contrib.messages.middleware.MessageMiddleware&#xA;50 &amp;lt;class &#39;django.contrib.messages.middleware.MessageMiddleware&#39;&amp;gt;&#xA;45 django.handler.base.BaseHandler&#xA;46 django.middleware.clickjacking.XFrameOptionsMiddleware&#xA;50 &amp;lt;class &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们来看看 settings 中的配置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;MIDDLEWARE_CLASSES = (&#xA;    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,&#xA;    &#39;django.middleware.common.CommonMiddleware&#39;,&#xA;    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,&#xA;    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,&#xA;    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,&#xA;    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看出，和配置的顺序是一样的。&#xA;中间件虽然加载完毕了，但是还没有调用，我们来继续看看下一个关键函数 get_response。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们先来看看中间件的加载顺序：&#xA;1. process_request&#xA;2. process_view&#xA;3. process_template_response&#xA;4. process_response&#xA;5. process_exception&lt;/p&gt;&#xA;&#xA;&lt;p&gt;看到这里，我们先来看看 Django 的官方文档&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;1-process-request&#34;&gt;1.process_request&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;It should return either None or an HttpResponse object. If it returns None, Django will continue processing this request, executing any other process_request() middleware, then, process_view() middleware, and finally, the appropriate view. If it returns an HttpResponse object, Django won’t bother calling any other request, view or exception middleware, or the appropriate view; it’ll apply response middleware to that HttpResponse, and return the result.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;它（process_request）返回 None 或者一个 HttpResponse 对象，如果返回None，Django将会继续处理这个请求，&#xA;执行其它的请求中间件。然后执行视图中间件，然后执行视图函数。一旦Django返回HttpResponse对象，它就不会再执行其它的 （请求、视图、异常）中间件，也不会再执行对应的视图函数。它将调用响应中间件，然后返回结果。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4 id=&#34;2-process-view&#34;&gt;2. process_view&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;process_view(request, view_func, view_args, view_kwargs)&#xA;request is an HttpRequest object. view_func is the Python function that Django is about to use. (It’s the actual function object, not the name of the function as a string.) view_args is a list of positional arguments that will be passed to the view, and view_kwargs is a dictionary of keyword arguments that will be passed to the view. Neither view_args nor view_kwargs include the first view argument (request).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;process_view() is called just before Django calls the view.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It should return either None or an HttpResponse object. If it returns None, Django will continue processing this request, executing any other process_view() middleware and, then, the appropriate view. If it returns an HttpResponse object, Django won’t bother calling any other view or exception middleware, or the appropriate view; it’ll apply response middleware to that HttpResponse, and return the result.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Django 在调用视图函数前调用 process_view&lt;/p&gt;&#xA;&#xA;&lt;p&gt;request 是一个 HttpRequest 对象，view_func 是一个函数对象，而不是函数名字对应的字符串。view_args 和 view_kwargs 是传入的参数（都不包括 request ）&#xA;执行会返回 None 或者 HttpResponse 对象，如果返回None， Django将会继续处理这个请求（request），继续执行其它的 process_view 中间件，然后是匹配的视图函数。一旦返回 HttpResponse 对象，就不会再执行其它的 视图中间件 和 异常中间件，以及对应的视图函数。&#xA;它将会继续调用 响应中间件，然后返回。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;看到这里，我们再来看看代码&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;            if response is None:&#xA;                if hasattr(request, &#39;urlconf&#39;):&#xA;                    # Reset url resolver with a custom urlconf.&#xA;                    urlconf = request.urlconf&#xA;                    urlresolvers.set_urlconf(urlconf)&#xA;                    resolver = urlresolvers.RegexURLResolver(r&#39;^/&#39;, urlconf)&#xA;&#xA;                resolver_match = resolver.resolve(request.path_info)&#xA;&#xA;                # ResolverMatch(func=&amp;lt;function index at 0x2373cf0&amp;gt;, args=(), kwargs={}, url_name=&#39;index&#39;, app_name=&#39;None&#39;, namespace=&#39;&#39;)&#xA;                callback, callback_args, callback_kwargs = resolver_match&#xA;                request.resolver_match = resolver_match&#xA;&#xA;                # Apply view middleware&#xA;                for middleware_method in self._view_middleware:&#xA;                    print middleware_method,123&#xA;                    response = middleware_method(request, callback, callback_args, callback_kwargs)&#xA;                    if response:&#xA;                        break&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;callback 就是中间件需要的函数对象，作为 process_view 参数中的 view_func&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h4 id=&#34;3-视图的处理&#34;&gt;3. 视图的处理&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;            if response is None:&#xA;                print callback&#xA;                wrapped_callback = self.make_view_atomic(callback)&#xA;                print wrapped_callback&#xA;                try:&#xA;                    response = wrapped_callback(request, *callback_args, **callback_kwargs)&#xA;                except Exception as e:&#xA;                    # If the view raised an exception, run it through exception&#xA;                    # middleware, and if the exception middleware returns a&#xA;                    # response, use that. Otherwise, reraise the exception.&#xA;                    for middleware_method in self._exception_middleware:&#xA;                        response = middleware_method(request, e)&#xA;                        if response:&#xA;                            break&#xA;                    if response is None:&#xA;                        raise&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果 response 是None ，执行视图函数，否则跳转到 响应中间件。&#xA;如果执行视图函数返回了 HttpResponse 对象，就跳转到 响应中间件。&#xA;如果执行视图函数出现异常，执行异常中间件。&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;4-异常中间件-process-exception&#34;&gt;4. 异常中间件 process_exception&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;process_exception(request, exception)&#xA;request is an HttpRequest object. exception is an Exception object raised by the view function.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Django calls process_exception() when a view raises an exception. process_exception() should return either None or an HttpResponse object. If it returns an HttpResponse object, the template response and response middleware will be applied, and the resulting response returned to the browser. Otherwise, default exception handling kicks in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Again, middleware are run in reverse order during the response phase, which includes process_exception. If an exception middleware returns a response, the middleware classes above that middleware will not be called at all.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;request 是一个 HttpRequest 对象，exception 是一个从视图抛出的异常对象。&#xA;当视图抛出异常，Django将会调用 process_exception 中间件，然后返回 None 或者 HttpResponse 对象。&#xA;如果返回 HttpResponse 对象，process_template_response 中间件 和 process_response中间件 将会被继续调用。&#xA;如果返回None，默认的异常就会被触发。&#xA;此外，在 response 逐步形成的阶段，中间件的调用是和加载顺序相反的，包括 process_exception。也就是说，如果某个中间件返回了 response，在这个中间件之上的中间件都不会被调用。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4 id=&#34;5-异常-视图没有返回-httpresponse-对象&#34;&gt;5. 异常（视图没有返回 HttpResponse 对象）&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;            if response is None:&#xA;                if isinstance(callback, types.FunctionType):    # FBV&#xA;                    view_name = callback.__name__&#xA;                else:                                           # CBV&#xA;                    view_name = callback.__class__.__name__ + &#39;.__call__&#39;&#xA;                raise ValueError(&amp;quot;The view %s.%s didn&#39;t return an HttpResponse object.&amp;quot; % (callback.__module__, view_name))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4 id=&#34;6-process-template-response-中间件&#34;&gt;6. process_template_response 中间件&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;process_template_response(request, response)&#xA;request is an HttpRequest object. response is the TemplateResponse object (or equivalent) returned by a Django view or by a middleware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;process_template_response() is called just after the view has finished executing, if the response instance has a render() method, indicating that it is a TemplateResponse or equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It must return a response object that implements a render method. It could alter the given response by changing response.template_name and response.context_data, or it could create and return a brand-new TemplateResponse or equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You don’t need to explicitly render responses – responses will be automatically rendered once all template response middleware has been called.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Middleware are run in reverse order during the response phase, which includes process_template_response().&lt;/p&gt;&#xA;&#xA;&lt;p&gt;request 是HttpRequest对象，response 是一个 TemplateResponse 对象，或者由&lt;strong&gt;视图 或 其他中间件&lt;/strong&gt; 产生的等效的对象.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在视图执行完毕之后，如果 response 实例包含 render 方法，表明这是一个 TemplateResponse 对象或者等效的对象，process_template_response 中间件就会被调用.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它必须返回一个继承有 render 方法的 response 对象，这可能会改变原有的 response 中的 template_name 和 context_data，或者创建一个全新的 TemplateResponse对象（或等效对象）.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你不必显示渲染 responses， responses 会在所有 template response 中间件调用结束后自动渲染.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在生成 response 阶段，所有的中间件都是反向运行的，其中自然包括了 process_template_response.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;到这里我查了下google ，资料很少，应该是几乎没有人用，或者没有展示出来.&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;7-process-response&#34;&gt;7. process_response&lt;/h4&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;process_response(request, response)&#xA;request is an HttpRequest object. response is the HttpResponse or StreamingHttpResponse object returned by a Django view or by a middleware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;request 是 HttpRequest 对象，response 是 视图或中间件返回的 HttpResponse或 StreamingHttpResponse对象.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;process_response() is called on all responses before they’re returned to the browser.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在返回数据到浏览器之前，process_response 会对所有的 responses进行处理.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It must return an HttpResponse or StreamingHttpResponse object. It could alter the given response, or it could create and return a brand-new HttpResponse or StreamingHttpResponse.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;结果必须返回一个 HttpResponse 或 StreamingHttpResponse 对象，它可能修改已有的对象，也可能创建一个全新的 HttpResponse 或 StreamingHttpResponse 对象.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unlike the process_request() and process_view() methods, the process_response() method is always called, even if the process_request() and process_view() methods of the same middleware class were skipped (because an earlier middleware method returned an HttpResponse). In particular, this means that your process_response() method cannot rely on setup done in process_request().&lt;/p&gt;&#xA;&#xA;&lt;p&gt;和process_request 和 process_view 不一样，process_response 总是会被调用的.&#xA;即使跳过了 process_request 和 process_view 方法(因为在这之前就生成了HttpResponse)&#xA;尤其需要注意的是，你的process_response 不能依赖 process_request.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, remember that during the response phase, middleware are applied in reverse order, from the bottom up. This means classes defined at the end of MIDDLEWARE_CLASSES will be run first.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，一点要记住，在response 生成的阶段，中间件是从下往上被调用的，这表示定义在后面的中间件将会被先执行.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;</description>
      <pubDate>Tue, 15 Mar 2016 23:46:03 +0000</pubDate>
    </item>
    <item>
      <title>从零开始分析 Django 源码 (一)</title>
      <link>http://www.r3call.com/2016/3/15/从零开始分析Django源码1.html</link>
      <description>&lt;h3 id=&#34;从-startproject-开始&#34;&gt;从 &lt;em&gt;startproject&lt;/em&gt; 开始&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;还记得最初我们是如何开始 Django 项目的么？&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;django-admin startproject mysite&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;so，找到&#xA;&lt;code&gt;Django/bin/django-admin.py&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python&#xA;from django.core import management&#xA;&#xA;if __name__ == &amp;quot;__main__&amp;quot;:&#xA;    management.execute_from_command_line()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;OK，它是从 management 来的，我们继续跟进。&#xA;找到&#xA;&lt;code&gt;Django/core/management/__init__.py&lt;/code&gt;&#xA;最后几行&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def execute_from_command_line(argv=None):&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    A simple method that runs a ManagementUtility.&#xA;    &amp;quot;&amp;quot;&amp;quot;&#xA;    utility = ManagementUtility(argv)&#xA;    utility.execute()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;ManagementUtility 的一个对象，并调用了 execute&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ManagementUtility 的定义就在函数的上面，我们先来看它的 execute&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def execute(self):&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        Given the command-line arguments, this figures out which subcommand is&#xA;        being run, creates a parser appropriate to that command, and runs it.&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        # Preprocess options to extract --settings and --pythonpath.&#xA;        # These options could affect the commands that are available, so they&#xA;        # must be processed early.&#xA;        parser = LaxOptionParser(usage=&amp;quot;%prog subcommand [options] [args]&amp;quot;,&#xA;                                 version=get_version(),&#xA;                                 option_list=BaseCommand.option_list)&#xA;        self.autocomplete()&#xA;        try:&#xA;            options, args = parser.parse_args(self.argv)&#xA;            handle_default_options(options)&#xA;        except:&#xA;            pass # Ignore any option errors at this point.&#xA;&#xA;        try:&#xA;            subcommand = self.argv[1]&#xA;        except IndexError:&#xA;            subcommand = &#39;help&#39; # Display help if no arguments were given.&#xA;&#xA;        if subcommand == &#39;help&#39;:&#xA;            if len(args) &amp;lt;= 2:&#xA;                parser.print_lax_help()&#xA;                sys.stdout.write(self.main_help_text() + &#39;\n&#39;)&#xA;            elif args[2] == &#39;--commands&#39;:&#xA;                sys.stdout.write(self.main_help_text(commands_only=True) + &#39;\n&#39;)&#xA;            else:&#xA;                self.fetch_command(args[2]).print_help(self.prog_name, args[2])&#xA;        elif subcommand == &#39;version&#39;:&#xA;            sys.stdout.write(parser.get_version() + &#39;\n&#39;)&#xA;        # Special-cases: We want &#39;django-admin.py --version&#39; and&#xA;        # &#39;django-admin.py --help&#39; to work, for backwards compatibility.&#xA;        elif self.argv[1:] == [&#39;--version&#39;]:&#xA;            # LaxOptionParser already takes care of printing the version.&#xA;            pass&#xA;        elif self.argv[1:] in ([&#39;--help&#39;], [&#39;-h&#39;]):&#xA;            parser.print_lax_help()&#xA;            sys.stdout.write(self.main_help_text() + &#39;\n&#39;)&#xA;        else:&#xA;            self.fetch_command(subcommand).run_from_argv(self.argv)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中就是一些判断，根据参数执行不同的操作，比如打印帮助，打印版本信息等等。&#xA;真正的命令会在&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.fetch_command(subcommand).run_from_argv(self.argv)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从这里执行&#xA;&lt;code&gt;self.fetch_command(subcommand)&lt;/code&gt; 返回的会是 &lt;em&gt;BaseCommand&lt;/em&gt; 及其子类的对象。&#xA;然后调用对象的 run_from_argv 方法。&#xA;我们尝试去找 startproject 的 Command&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在&#xA;&lt;code&gt;Django/core/management/command/startproject.py&lt;/code&gt;&#xA;但其中的 Command 并没有 run_from_argv ，只知道其父类 是 TemplateCommand&#xA;继续跟进， TemplateCommand 也没有 run_from_argv ， 其父类是 BaseCommand&#xA;BaseCommand 中有 run_from_argv 这个方法。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def run_from_argv(self, argv):&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        Set up any environment changes requested (e.g., Python path&#xA;        and Django settings), then run this command. If the&#xA;        command raises a ``CommandError``, intercept it and print it sensibly&#xA;        to stderr. If the ``--traceback`` option is present or the raised&#xA;        ``Exception`` is not ``CommandError``, raise it.&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        parser = self.create_parser(argv[0], argv[1])&#xA;        options, args = parser.parse_args(argv[2:])&#xA;        handle_default_options(options)&#xA;        try:&#xA;            self.execute(*args, **options.__dict__)&#xA;        except Exception as e:&#xA;            if options.traceback or not isinstance(e, CommandError):&#xA;                raise&#xA;&#xA;            # self.stderr is not guaranteed to be set here&#xA;            stderr = getattr(self, &#39;stderr&#39;, OutputWrapper(sys.stderr, self.style.ERROR))&#xA;            stderr.write(&#39;%s: %s&#39; % (e.__class__.__name__, e))&#xA;            sys.exit(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我尝试做些修改，看看输出会变成什么&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def run_from_argv(self, argv):&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        Set up any environment changes requested (e.g., Python path&#xA;        and Django settings), then run this command. If the&#xA;        command raises a ``CommandError``, intercept it and print it sensibly&#xA;        to stderr. If the ``--traceback`` option is present or the raised&#xA;        ``Exception`` is not ``CommandError``, raise it.&#xA;        &amp;quot;&amp;quot;&amp;quot;&#xA;        print 238,argv&#xA;        sys.exit(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我在终端中输入&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;django-admin.py startproject testproject&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;结果反馈了&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;238 [&#39;/path/to/pycode/dj1.6.11/bin/django-admin.py&#39;, &#39;startproject&#39;, &#39;testproject&#39;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;同样，我们继续看&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;        print 240,options&#xA;        print 241,args&#xA;        sys.exit(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;会输出什么&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;240 {&#39;files&#39;: [], &#39;settings&#39;: None, &#39;pythonpath&#39;: None, &#39;verbosity&#39;: u&#39;1&#39;, &#39;traceback&#39;: None, &#39;extensions&#39;: [&#39;py&#39;], &#39;template&#39;: None}&#xA;241 [&#39;testproject&#39;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看到这，handle_default_options 我们就先不看了，而是看 execute&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.execute(*args, **options.__dict__)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;后面会执行到 output = self.handle(*args, **options)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们来看 startproject 命令 对应的 handle&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Command(TemplateCommand):&#xA;    help = (&amp;quot;Creates a Django project directory structure for the given &amp;quot;&#xA;            &amp;quot;project name in the current directory or optionally in the &amp;quot;&#xA;            &amp;quot;given directory.&amp;quot;)&#xA;&#xA;    def handle(self, project_name=None, target=None, *args, **options):&#xA;        self.validate_name(project_name, &amp;quot;project&amp;quot;)&#xA;&#xA;        # Check that the project_name cannot be imported.&#xA;        try:&#xA;            import_module(project_name)&#xA;        except ImportError:&#xA;            pass&#xA;        else:&#xA;            raise CommandError(&amp;quot;%r conflicts with the name of an existing &amp;quot;&#xA;                               &amp;quot;Python module and cannot be used as a &amp;quot;&#xA;                               &amp;quot;project name. Please try another name.&amp;quot; %&#xA;                               project_name)&#xA;&#xA;        # Create a random SECRET_KEY hash to put it in the main settings.&#xA;        chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;amp;*(-_=+)&#39;&#xA;        options[&#39;secret_key&#39;] = get_random_string(50, chars)&#xA;&#xA;        super(Command, self).handle(&#39;project&#39;, project_name, target, **options)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里会进行一个验证，然后尝试将 project_name 作为模块导入。&#xA;生成 secret_key，最后调用&#xA;TemplateCommand 类的 handle 方法，继续处理&lt;/p&gt;&#xA;&#xA;&lt;p&gt;剩下的下次分析。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天继续&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def handle(self, app_or_project, name, target=None, **options):&#xA;        self.app_or_project = app_or_project&#xA;        self.paths_to_remove = []&#xA;        self.verbosity = int(options.get(&#39;verbosity&#39;))&#xA;&#xA;        self.validate_name(name, app_or_project)&#xA;&#xA;        # if some directory is given, make sure it&#39;s nicely expanded&#xA;        # 如果没有指定 target ，则把当前目录 连接项目名称 作为 项目目录&#xA;        if target is None:&#xA;            top_dir = path.join(os.getcwd(), name)&#xA;            try:&#xA;                print 76,top_dir&#xA;                os.makedirs(top_dir)&#xA;            except OSError as e:&#xA;                if e.errno == errno.EEXIST:&#xA;                    message = &amp;quot;&#39;%s&#39; already exists&amp;quot; % top_dir&#xA;                else:&#xA;                    message = e&#xA;                raise CommandError(message)&#xA;        # 否则使用 target 的目录作为项目目录&#xA;        else:&#xA;            top_dir = os.path.abspath(path.expanduser(target))&#xA;            if not os.path.exists(top_dir):&#xA;                raise CommandError(&amp;quot;Destination directory &#39;%s&#39; does not &amp;quot;&#xA;                                   &amp;quot;exist, please create it first.&amp;quot; % top_dir)&#xA;&#xA;        extensions = tuple(&#xA;            handle_extensions(options.get(&#39;extensions&#39;), ignored=()))&#xA;        extra_files = []&#xA;        for file in options.get(&#39;files&#39;):&#xA;            extra_files.extend(map(lambda x: x.strip(), file.split(&#39;,&#39;)))&#xA;        if self.verbosity &amp;gt;= 2:&#xA;            self.stdout.write(&amp;quot;Rendering %s template files with &amp;quot;&#xA;                              &amp;quot;extensions: %s\n&amp;quot; %&#xA;                              (app_or_project, &#39;, &#39;.join(extensions)))&#xA;            self.stdout.write(&amp;quot;Rendering %s template files with &amp;quot;&#xA;                              &amp;quot;filenames: %s\n&amp;quot; %&#xA;                              (app_or_project, &#39;, &#39;.join(extra_files)))&#xA;&#xA;        base_name = &#39;%s_name&#39; % app_or_project&#xA;        base_subdir = &#39;%s_template&#39; % app_or_project&#xA;        base_directory = &#39;%s_directory&#39; % app_or_project&#xA;        if django.VERSION[-2] != &#39;final&#39;:&#xA;            docs_version = &#39;dev&#39;&#xA;        else:&#xA;            docs_version = &#39;%d.%d&#39; % django.VERSION[:2]&#xA;&#xA;        context = Context(dict(options, **{&#xA;            base_name: name,&#xA;            base_directory: top_dir,&#xA;            &#39;docs_version&#39;: docs_version,&#xA;        }), autoescape=False)&#xA;&#xA;        # Setup a stub settings environment for template rendering&#xA;        from django.conf import settings&#xA;        if not settings.configured:&#xA;            settings.configure()&#xA;&#xA;        template_dir = self.handle_template(options.get(&#39;template&#39;),&#xA;                                            base_subdir)&#xA;        prefix_length = len(template_dir) + 1&#xA;&#xA;        print 128,template_dir&#xA;        for root, dirs, files in os.walk(template_dir):&#xA;&#xA;            path_rest = root[prefix_length:]&#xA;            relative_dir = path_rest.replace(base_name, name)&#xA;            if relative_dir:&#xA;                target_dir = path.join(top_dir, relative_dir)&#xA;                if not path.exists(target_dir):&#xA;                    os.mkdir(target_dir)&#xA;&#xA;            for dirname in dirs[:]:&#xA;                if dirname.startswith(&#39;.&#39;) or dirname == &#39;__pycache__&#39;:&#xA;                    dirs.remove(dirname)&#xA;&#xA;            for filename in files:&#xA;                if filename.endswith((&#39;.pyo&#39;, &#39;.pyc&#39;, &#39;.py.class&#39;)):&#xA;                    # Ignore some files as they cause various breakages.&#xA;                    continue&#xA;                old_path = path.join(root, filename)&#xA;                new_path = path.join(top_dir, relative_dir,&#xA;                                     filename.replace(base_name, name))&#xA;                if path.exists(new_path):&#xA;                    raise CommandError(&amp;quot;%s already exists, overlaying a &amp;quot;&#xA;                                       &amp;quot;project or app into an existing &amp;quot;&#xA;                                       &amp;quot;directory won&#39;t replace conflicting &amp;quot;&#xA;                                       &amp;quot;files&amp;quot; % new_path)&#xA;&#xA;                # Only render the Python files, as we don&#39;t want to&#xA;                # accidentally render Django templates files&#xA;                with open(old_path, &#39;rb&#39;) as template_file:&#xA;                    content = template_file.read()&#xA;                if filename.endswith(extensions) or filename in extra_files:&#xA;                    content = content.decode(&#39;utf-8&#39;)&#xA;                    template = Template(content)&#xA;                    content = template.render(context)&#xA;                    content = content.encode(&#39;utf-8&#39;)&#xA;                with open(new_path, &#39;wb&#39;) as new_file:&#xA;                    new_file.write(content)&#xA;&#xA;                if self.verbosity &amp;gt;= 2:&#xA;                    self.stdout.write(&amp;quot;Creating %s\n&amp;quot; % new_path)&#xA;                try:&#xA;                    shutil.copymode(old_path, new_path)&#xA;                    self.make_writeable(new_path)&#xA;                except OSError:&#xA;                    self.stderr.write(&#xA;                        &amp;quot;Notice: Couldn&#39;t set permission bits on %s. You&#39;re &amp;quot;&#xA;                        &amp;quot;probably using an uncommon filesystem setup. No &amp;quot;&#xA;                        &amp;quot;problem.&amp;quot; % new_path, self.style.NOTICE)&#xA;&#xA;        if self.paths_to_remove:&#xA;            if self.verbosity &amp;gt;= 2:&#xA;                self.stdout.write(&amp;quot;Cleaning up temporary files.\n&amp;quot;)&#xA;            for path_to_remove in self.paths_to_remove:&#xA;                if path.isfile(path_to_remove):&#xA;                    os.remove(path_to_remove)&#xA;                else:&#xA;                    shutil.rmtree(path_to_remove,&#xA;                                  onerror=rmtree_errorhandler)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;终端中执行&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;django-admin.py startproject -v 3 testproject&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;有以下输出&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Rendering project template files with extensions: .py&#xA;Rendering project template files with filenames: &#xA;128 /path/to/django/dj1.6.11/local/lib/python2.7/site-packages/django/conf/project_template&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/manage.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testproject/settings.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testproject/wsgi.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testproject/__init__.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testproject/urls.py&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;很容易就看到，它从 Django/conf/project_template 中拷贝文件到新创建的项目中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了， startproject 分析到此结束。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;同理，startapp 也是一样，从 Django/conf/app_template 下拷贝文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Rendering app template files with extensions: .py&#xA;Rendering app template files with filenames: &#xA;128 /path/to/django/dj1.6.11/local/lib/python2.7/site-packages/django/conf/app_template&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testapp/admin.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testapp/__init__.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testapp/models.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testapp/tests.py&#xA;Creating /home/pi/pycode/dj1.6.11/testproject/testapp/views.py&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <pubDate>Tue, 15 Mar 2016 23:04:30 +0000</pubDate>
    </item>
  </channel>
</rss>